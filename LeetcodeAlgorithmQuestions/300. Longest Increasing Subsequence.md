# Solution 1 Brute force recursive solution

The straight forward and simplest solution is to find all the increasing subsequence and return the length of the longest increasing subsequence. This can be achieved using a recursive function. This function will return the length of the LIS possible from current elements onwards(including current element). Inside each function call, there are 2 possible conditions:

1. Current element is greater than the previous element included in the LIS. In this case, we can either include the current element in the LIS or not include the current element in the LIS. Thus we find both length of the LIS. The value returned by the function call is, thus, the greater one out of the 2 lengths. 

2. Current element is smaller than the previous element included in the LIS. Hence we cannot include this element in the LIS. So we only find the length of the LIS possible by not including the current element, which is returned by the function call. 

Suppose the number the length of `n`. 

Time complexity: `O(2^n)`. Size of the recursion tree. 

Space complexity: `O(1)`. 

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        return lengthOfLIS(nums, Integer.MIN_VALUE, 0);
    }
    
    private int lengthOfLIS(int[] nums, int prev, int pos) {
        if (pos == nums.length) {
            return 0;
        }
        int taken = 0;
        if (nums[pos] > prev) {
            taken = 1 + lengthOfLIS(nums, nums[pos], pos + 1);
        }
        int notTaken = lengthOfLIS(nums, prev, pos + 1);
        return Math.max(taken, notTaken);
    }
}
```
