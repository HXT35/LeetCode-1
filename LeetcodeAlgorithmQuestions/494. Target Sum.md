# Solution1 DFS Brute Force

If we treat the whole solution space as a binary tree, then actually every possible sum is the leaf node of the tree. For every number, there are 2 branches for it, one for `+` symbol, one for `-` symbol. We can use DFS to traverse the whole tree and find the sum that equals to what give. 

Time complexity `O(2^n)`, since the tree has a depth of `n`, and a depth-n binary tree have `2^n` leaf nodes of which we have to check all.
Space complexity `O(n)`, since the recursion goes to depth `n`. 

Java implementation.

```
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int ret = findTargetSumWays(nums, S, 0, 0);
        return ret;
    }
    
    private int findTargetSumWays(int[] nums, int S, int currSum, int pos) {
        if (pos == nums.length) {
            return currSum == S ? 1 : 0;
        }
        
        // symbol `+`
        int left = currSum + nums[pos];
        // symbol `-`
        int right = currSum - nums[pos];
        return findTargetSumWays(nums, S, left, pos + 1) + findTargetSumWays(nums, S, right, pos + 1);
    }
}
```

# Solution2 DFS with Memorization

During the previous step, we have actually did a lot of redundant work by keep checking the same conditions defined by a unique `(pos, currSum)` pairs. Thus we could remember this condition and thus improve the efficiency of our algorithm. Meanwhile, considering that `currSum` can be poritive or negative, we need find a way to be able to keep it in positive indexed array. Recall that the questions mentioned that The sum of elements in the given array will not exceed 1000, we could shift the sum-index to the left by 1000. 

Time complexity: `O(l*n)` where l is the range of the sum and n is the length of the input array. Sincer the 2-dimensional array we used as memorization will be filled for only once, `O(l*n)` is the time complexity. 
Space complexity: `O(l*n)` as well because of memorization. 

Java implementation:

```
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int[][] mem = new int[nums.length][2000];
        for (int[] row : mem) {
            Arrays.fill(row, Integer.MIN_VALUE);
        }
        int ret = findTargetSumWays(nums, S, 0, 0, mem);
        return ret;
    }
    
    private int findTargetSumWays(int[] nums, int S, int currSum, int pos, int[][] mem) {
        if (pos == nums.length) {
            return currSum == S ? 1 : 0;
        }
        
        // already memorized
        if (mem[pos][currSum + 1000] != Integer.MIN_VALUE) {
            return mem[pos][currSum + 1000];
        }
        
        // symbol `+`
        int left = findTargetSumWays(nums, S, currSum + nums[pos], pos + 1, mem);
        // symbol `-`
        int right = findTargetSumWays(nums, S, currSum - nums[pos], pos + 1, mem);
        mem[pos][currSum + 1000] = left + right;
        return mem[pos][currSum + 1000];
    }
}
```
