# Solution1: Binary Search Tree Inserting and Searching

Since we have need to go to position `i` in order to know what are the positions that have flowers blooming until this day, we need to at least visit each positon in `flowers[]` array to check for the result. This gives us a lower bound of the algorithm running time -- `O(n)`. 

And during the checking of each position, we need to figure out a way to check the requirement for the flowers, which is, there should be `k` empty slots between 2 blooming flowers. Since for each day `i`, we are only adding a newly blooming flower at `flowers[i]`, we only need to check 2 positions relative to this newly added flower, the highest position that is lower than current position and the lowest position that is higher than current position. Considering of this fact, a suitable data structure, apprently, is a Binary Search Tree, which giving us the nice feature of checking a predecessor and postdecessor for a given number within `O(logn)` time.  

Hence we come up with the following algorithm:   
1. From day `1` to day `N`, add each flower to the corresponding position `flowers[i]` in a TreeSet, which is a Java Red Black Tree implementation.  
2. Each time a new flower is added, check the lowest higher position `high` and highest lower position `low` in the TreeMap.  
  1. If either of them satisfies the requirement, return this `day`.  
  2. Otherwise, continue the process. 

Time complexity: `O(N * 2logN) = O(NlogN)`  

Space complexity: `O(N)`  

```Java
class Solution {
    public int kEmptySlots(int[] flowers, int k) {
        TreeSet<Integer> bloomed = new TreeSet<>();
        int day = 0;
        for (; day < flowers.length; day++) {
            bloomed.add(flowers[day]);
            Integer low = bloomed.lower(flowers[day]);
            Integer high = bloomed.higher(flowers[day]);
            if ((low != null && flowers[day] - low - 1 == k) || (high != null && high - flowers[day] - 1 == k)) {
                return day + 1;
            }
        }
        
        return -1;
    }
}
```

# Solution2: 
